<h2 align="center">Описание <a href="https://github.com/Alekseeva-Dana/tasks/tree/main/tasks/task6" target="_blank">Task6</h2>
Суть задания: 
«Философы»
Пять философов гуляют по саду и размышляют, время от времени заходя в беседку
(столовую) подкрепиться — там круглый стол с пятью стульями и блюдом спагетти в
центре стола. Спагетти длинные и скользкие — чтобы их кушать, нужны две вилки. На
столе всего пять вилок. Места философов фиксированы: i-й философ садится на i-й стул.
Когда философ садится за стол, он должен взять левую вилку, если она свободна (иначе
ждать пока сосед слева поест и положит вилку), взять правую вилку (если она занята,
подождать), затем покушать с помощью двух вилок, положить левую и правую вилки и
пойти в сад продолжить размышления. Исключить возможность тупиковой ситуации,
когда все философы сели за стол и взяли левую вилку
<h3 align = "center">Реализация</h3>
<pre><code>#define N 5
#define LEFT (i-1+N)%N
#define RIGHT (i+1)%N</pre></code>
N=5 - количество философов
LEFT и RIGHT - макросы для вычисления индексов соседей
Возможные состояния философов: думает, голоден, ест
Функция Think - философ думает
<pre><code>void Think(int i) {
    printf("Философ %d размышляет...\n", i);
    sleep(rand() % 3 + 1);   
}</code></pre>
Функция Eat - философ ест 
<pre><code>void Eat(int i) {
    printf("Философ %d ест спагетти\n", i);
    sleep(rand() % 2 + 1);   
}</code></pre>
Функция Test - проверка возможности взять вилки
<pre><code>void Test(int i) {
    if(state[i] == HUNGRY &&
       state[LEFT] != EATING &&
       state[RIGHT] != EATING) {
        state[i] = EATING;
        sem_post(&s[i]);     
    }
}</code></pre>
Если философ голоден и оба соседа не едят, он может начать есть
TakeForks - взять вилки
<pre><code>void TakeForks(int i) {
    sem_wait(&mutex);       
    state[i] = HUNGRY;
    printf("Философ %d голоден\n", i);
    Test(i);                 
    sem_post(&mutex);       
    sem_wait(&s[i]);         
}</code></pre>
PutForks - положить вилки
<pre><code>void PutForks(int i) {
    sem_wait(&mutex);        
    state[i] = THINKING;
    printf("Философ %d закончил есть и положил вилки\n", i);
    Test(LEFT);             
    Test(RIGHT);             
    sem_post(&mutex);        
}</code></pre>


1. **Философ `i` освобождает вилки** и переходит в состояние `THINKING`

2. **Проверяются оба соседа** (LEFT и RIGHT):
   - `Test(LEFT)` — может ли левый сосед теперь поесть?
   - `Test(RIGHT)` — может ли правый сосед теперь поесть?

3. **Если сосед голоден и может есть** (его соседи не едят):
   - Его состояние меняется на `EATING`
   - Он **разблокируется** (`up(&s[сосед])`)
   - Начинает есть

4. **Цикл повторяется** — философ снова начинает думать (`Think(i)`)

**Итог:** Освобождение вилок **пробуждает голодных соседей**, предотвращая взаимоблокировки и обеспечивая прогресс.
